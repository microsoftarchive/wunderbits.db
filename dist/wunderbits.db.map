{
  "version": 3,
  "sources": [
    "wunderbits.db/node_modules/gulp-cjs/node_modules/browserify/node_modules/browser-pack/_prelude.js",
    "wunderbits.db/node_modules/wunderbits.core/public/BaseEventEmitter.js",
    "wunderbits.db/node_modules/wunderbits.core/public/BaseSingleton.js",
    "wunderbits.db/node_modules/wunderbits.core/public/WBClass.js",
    "wunderbits.db/node_modules/wunderbits.core/public/WBDeferred.js",
    "wunderbits.db/node_modules/wunderbits.core/public/WBEventEmitter.js",
    "wunderbits.db/node_modules/wunderbits.core/public/WBMixin.js",
    "wunderbits.db/node_modules/wunderbits.core/public/WBPromise.js",
    "wunderbits.db/node_modules/wunderbits.core/public/WBSingleton.js",
    "wunderbits.db/node_modules/wunderbits.core/public/WBStateModel.js",
    "wunderbits.db/node_modules/wunderbits.core/public/index.js",
    "wunderbits.db/node_modules/wunderbits.core/public/lib/assert.js",
    "wunderbits.db/node_modules/wunderbits.core/public/lib/clone.js",
    "wunderbits.db/node_modules/wunderbits.core/public/lib/createUID.js",
    "wunderbits.db/node_modules/wunderbits.core/public/lib/debounce.js",
    "wunderbits.db/node_modules/wunderbits.core/public/lib/defer.js",
    "wunderbits.db/node_modules/wunderbits.core/public/lib/delay.js",
    "wunderbits.db/node_modules/wunderbits.core/public/lib/events.js",
    "wunderbits.db/node_modules/wunderbits.core/public/lib/extend.js",
    "wunderbits.db/node_modules/wunderbits.core/public/lib/forEach.js",
    "wunderbits.db/node_modules/wunderbits.core/public/lib/fromSuper.js",
    "wunderbits.db/node_modules/wunderbits.core/public/lib/functions.js",
    "wunderbits.db/node_modules/wunderbits.core/public/lib/index.js",
    "wunderbits.db/node_modules/wunderbits.core/public/lib/inherits.js",
    "wunderbits.db/node_modules/wunderbits.core/public/lib/isEqual.js",
    "wunderbits.db/node_modules/wunderbits.core/public/lib/merge.js",
    "wunderbits.db/node_modules/wunderbits.core/public/lib/size.js",
    "wunderbits.db/node_modules/wunderbits.core/public/lib/toArray.js",
    "wunderbits.db/node_modules/wunderbits.core/public/lib/when.js",
    "wunderbits.db/node_modules/wunderbits.core/public/lib/where.js",
    "wunderbits.db/node_modules/wunderbits.core/public/mixins/ControllableMixin.js",
    "wunderbits.db/node_modules/wunderbits.core/public/mixins/ObservableHashMixin.js",
    "wunderbits.db/node_modules/wunderbits.core/public/mixins/WBBindableMixin.js",
    "wunderbits.db/node_modules/wunderbits.core/public/mixins/WBDestroyableMixin.js",
    "wunderbits.db/node_modules/wunderbits.core/public/mixins/WBEventsMixin.js",
    "wunderbits.db/node_modules/wunderbits.core/public/mixins/WBStateMixin.js",
    "wunderbits.db/node_modules/wunderbits.core/public/mixins/WBUtilsMixin.js",
    "wunderbits.db/node_modules/wunderbits.core/public/mixins/index.js",
    "wunderbits.db/public/BackboneDBSync.js",
    "wunderbits.db/public/Backends/AbstractBackend.js",
    "wunderbits.db/public/Backends/IndexedDBBackend.js",
    "wunderbits.db/public/Backends/MemoryBackend.js",
    "wunderbits.db/public/Backends/WebSQLBackend.js",
    "wunderbits.db/public/WBDatabase.js",
    "wunderbits.db/public/WBLocalStorage.js",
    "wunderbits.db/public/WBSchema.js",
    "wunderbits.db/public/index.js",
    "wunderbits.db/public/lib/FieldTypes.js",
    "wunderbits.db/public/lib/SafeParse.js",
    "wunderbits.db/public/lib/generateId.js",
    "wunderbits.db/public/lib/printf.js",
    "wunderbits.db/public/localStorage/WBBrowserLocalStorage.js",
    "wunderbits.db/public/localStorage/WBChromeLocalStorage.js"
  ],
  "names": [],
  "mappings": "AAAA;ACAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACXA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACbA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACrHA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC3IA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACVA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACvFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACrCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACtDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACrEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACdA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC3CA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACjDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC5CA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC1BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACbA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACdA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACvOA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACzBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC1BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACjDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACbA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACrBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AChDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACRA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AClBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACRA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACtBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACzDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AClBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACjFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AClEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC3QA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACvDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACRA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AChHA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC1DA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACVA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACvIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACjGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACrXA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACzKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACndA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AChQA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACfA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACjDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACRA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACRA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACnBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACZA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACrBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACtDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA",
  "file": "wunderbits.db",
  "sourceRoot": "file://",
  "sourcesContent": [
    "(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\"function\"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);throw new Error(\"Cannot find module '\"+o+\"'\")}var f=n[o]={exports:{}};t[o][0].call(f.exports,function(e){var n=t[o][1][e];return s(n?n:e)},f,f.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\"function\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})",
    "'use strict';\n\nvar BaseEmitter = require('./WBEventEmitter').extend({\n  'mixins': [\n    require('./mixins/WBDestroyableMixin'),\n    require('./mixins/WBUtilsMixin'),\n    require('./mixins/ObservableHashMixin')\n  ]\n});\n\nmodule.exports = BaseEmitter;\n",
    "'use strict';\n\nvar BaseSingleton = require('./WBSingleton').extend({\n  'mixins': [\n    require('./mixins/WBEventsMixin'),\n    require('./mixins/WBBindableMixin'),\n    require('./mixins/WBDestroyableMixin'),\n    require('./mixins/WBUtilsMixin'),\n    require('./mixins/ObservableHashMixin')\n  ]\n});\n\nmodule.exports = BaseSingleton;\n",
    "'use strict';\n\nvar inherits = require('./lib/inherits');\nvar extend = require('./lib/extend');\nvar clone = require('./lib/clone');\nvar createUID = require('./lib/createUID');\nvar fromSuper = require('./lib/fromSuper');\n\n// Self-propagating extend function.\n// Create a new class,\n// that inherits from the class found in the `this` context object.\n// This function is meant to be called,\n// in the context of a constructor function.\nfunction extendSelf (protoProps, staticProps) {\n  /* jshint validthis:true */\n\n  var parent = this;\n\n  protoProps = protoProps || {};\n\n  // extract mixins, if any\n  var mixins = protoProps.mixins || [];\n  delete protoProps.mixins;\n\n  // create the derived class\n  var child = inherits(parent, protoProps, staticProps);\n\n  // apply mixins to the derived class\n  var mixin;\n  while (mixins.length) {\n    mixin = mixins.shift();\n    (typeof mixin.applyToClass === 'function') &&\n      mixin.applyToClass(child);\n  }\n\n  // make the child class extensible\n  child.extend = parent.extend || extendSelf;\n  return child;\n}\n\nfunction WBClass (options) {\n\n  var self = this;\n\n  // Assign a unique identifier to the instance\n  self.uid = self.uid || createUID();\n\n  // save options, make sure it's at least an empty object\n  self.options = options || self.options;\n\n  // augment properties from mixins\n  self.augmentProperties();\n\n  // initialize the instance\n  self.initialize.apply(self, arguments);\n\n  // initialize all the mixins, if needed\n  // don't keep this in the initialize,\n  // initialize can be overwritten\n  self.initMixins.apply(self, arguments);\n}\n\nvar proto = {\n\n  'initialize': function () {\n\n    // Return self to allow for subclass to assign\n    // super initializer value to self\n    var self = this;\n    return self;\n  },\n\n  // If any mixins were applied to the prototype, initialize them\n  'initMixins': function () {\n\n    var self = this;\n    var initializers = fromSuper.concat(self, 'initializers');\n\n    var initializer;\n    while (initializers.length) {\n      initializer = initializers.shift();\n      (typeof initializer === 'function') &&\n        initializer.apply(self, arguments);\n    }\n  },\n\n  // If any proerties were defined in the mixins, augment them to the instance\n  'augmentProperties': function () {\n\n    var self = this;\n    var properties = fromSuper.merge(self, 'properties');\n\n    function augmentProperty (property, value) {\n\n      var type = typeof value;\n\n      if (type === 'function') {\n        self[property] = value.call(self);\n      }\n      else if (type === 'object') {\n        self[property] = clone(value, true);\n      }\n      else {\n        self[property] = value;\n      }\n    }\n\n    for (var key in properties) {\n      augmentProperty(key, properties[key]);\n    }\n  }\n};\n\nextend(WBClass.prototype, proto);\nWBClass.extend = extendSelf;\n\nmodule.exports = WBClass;\n",
    "'use strict';\n\nvar WBClass = require('./WBClass');\nvar WBPromise = require('./WBPromise');\nvar assert = require('./lib/assert');\nvar toArray = require('./lib/toArray');\n\nvar states = {\n  'pending': 0,\n  'resolved': 2,\n  'rejected': 4\n};\n\nvar stateNames = {\n  0: ['pending'],\n  2: ['resolved', 'resolve'],\n  4: ['rejected', 'reject']\n};\n\nvar proto = {\n\n  'properties': {\n    '_state': states.pending,\n    '_args': [],\n    'handlers': []\n  },\n\n  'initialize': function (context) {\n    var self = this;\n    self._context = context;\n  },\n\n  'state': function () {\n    var self = this;\n    return stateNames[self._state][0];\n  },\n\n  'trigger': function (withContext) {\n\n    var self = this;\n    if (self._state === states.pending) {\n      return;\n    }\n\n    var handlers = self.handlers, handle;\n    while (handlers.length) {\n      handle = handlers.shift();\n      self.invoke(handle, withContext || self._context);\n    }\n  },\n\n  'invoke': function (deferredResponse, withContext) {\n\n    var self = this;\n    var state = self._state;\n    var context = deferredResponse.context || withContext || self;\n    var args = deferredResponse.args;\n\n    self._args.forEach(function (arg) {\n      // send single arguments as the item, otherwise send it as an array\n      args.push(arg);\n    });\n\n    var type = deferredResponse.type;\n    var isCompleted = (type === 'then') ||\n      (type === 'done' && state === states.resolved) ||\n      (type === 'fail' && state === states.rejected);\n\n    isCompleted && deferredResponse.fn.apply(context, args);\n  },\n\n  'promise': function () {\n    var self = this;\n    self._promise = self._promise || new WBPromise(this);\n    return self._promise;\n  }\n};\n\n['then', 'done', 'fail'].forEach(function (method) {\n  proto[method] = function () {\n\n    var self = this;\n\n    // store references to the context, callbacks, and arbitrary arguments\n    var args = toArray(arguments);\n    var fn = args.shift();\n    var context = args.shift();\n\n    assert.function(fn, method + ' accepts only functions');\n\n    self.handlers.push({\n      'type': method,\n      'context': context,\n      'fn': fn,\n      'args': args\n    });\n\n    // if the defered is not pending anymore, call the callbacks\n    self.trigger();\n\n    return self;\n  };\n});\n\n// Alias `always` to `then` on Deferred's prototype\nproto.always = proto.then;\n\nfunction resolver (state, isWith, fnName) {\n  return function complete () {\n\n    var self = this;\n\n    if (!(self instanceof WBDeferred)) {\n      throw new Error(fnName + ' invoked with wrong context');\n    }\n\n    // can't change state once resolved or rejected\n    if (self._state !== states.pending) {\n      return self;\n    }\n\n    self._args = toArray(arguments);\n    var context = isWith ? self._args.shift() : undefined;\n\n    self._state = state;\n    self.trigger(context);\n\n    return self;\n  };\n}\n\n[states.resolved, states.rejected].forEach(function (state) {\n  var fnName = stateNames[state][1];\n  proto[fnName] = resolver(state, false, fnName);\n  proto[fnName + 'With'] = resolver(state, true, fnName);\n});\n\nvar WBDeferred = WBClass.extend(proto);\nmodule.exports = WBDeferred;\n",
    "'use strict';\n\nvar WBEventEmitter = require('./WBClass').extend({\n  'mixins': [\n    require('./mixins/WBBindableMixin'),\n    require('./mixins/WBEventsMixin')\n  ]\n});\n\nmodule.exports = WBEventEmitter;\n",
    "'use strict';\n\nvar extend = require('./lib/extend');\nvar clone = require('./lib/clone');\nvar assert = require('./lib/assert');\nvar WBSingleton = require('./WBSingleton');\n\nvar WBMixin = WBSingleton.extend({\n\n  // Apply the mixin to an instance of a class\n  'applyTo': function (instance) {\n\n    var behavior = clone(this.Behavior, true);\n\n    // apply mixin's initialize & remove it from the instance\n    var initializer;\n    if (typeof behavior.initialize === 'function') {\n      initializer = behavior.initialize;\n      delete behavior.initialize;\n    }\n\n    // augment mixin's properties object into the instance\n    var properties = behavior.properties;\n    delete behavior.properties;\n\n    // mixin the behavior\n    extend(instance, behavior);\n\n    // apply the initializer, if any\n    initializer && initializer.apply(instance);\n\n    // augment proerties to the instance\n    properties && extend(instance, properties);\n\n    return instance;\n  },\n\n  // Apply the mixin to the class directly\n  'applyToClass': function (klass) {\n\n    // validate class\n    assert.class(klass, 'applyToClass expects a class');\n\n    var proto = klass.prototype;\n    var behavior = clone(this.Behavior, true);\n\n    // cache the mixin's initializer, to be applied later\n    var initialize = behavior.initialize;\n    if (typeof initialize === 'function') {\n      (!proto.hasOwnProperty('initializers')) && (proto.initializers = []);\n      proto.initializers.push(initialize);\n      delete behavior.initialize;\n    }\n\n    var properties = behavior.properties;\n    delete behavior.properties;\n\n    // extend the prototype\n    extend(proto, behavior);\n\n    // cache the properties, to be applied later\n    (!proto.hasOwnProperty('properties')) && (proto.properties = {});\n    properties && extend(proto.properties, properties);\n\n    return klass;\n  }\n});\n\n// The only real change from a simple singleton is\n// the altered extend class method, which will save\n// \"mixinProps\" into a specific member, for easy\n// and clean application using #applyTo\nWBMixin.extend = function (mixinProps, staticProps) {\n\n  mixinProps || (mixinProps = {});\n  staticProps || (staticProps = {});\n\n  var current = clone(this.Behavior, true);\n  staticProps.Behavior = extend(current, mixinProps);\n  var mixin = WBSingleton.extend.call(this, staticProps);\n\n  mixin.extend = WBMixin.extend;\n\n  return mixin;\n};\n\nmodule.exports = WBMixin;\n",
    "'use strict';\n\nvar WBClass = require('./WBClass');\n\nfunction proxy (name) {\n  return function () {\n    var deferred = this.deferred;\n    deferred[name].apply(deferred, arguments);\n    return this;\n  };\n}\n\nvar proto = {\n  'constructor': function (deferred) {\n    this.deferred = deferred;\n  },\n\n  'promise': function () {\n    return this;\n  },\n\n  'state': function () {\n    return this.deferred.state();\n  }\n};\n\n[\n  'done',\n  'fail',\n  'then'\n].forEach(function (name) {\n  proto[name] = proxy(name);\n});\n\nproto.always = proto.then;\n\nmodule.exports = WBClass.extend(proto);\n",
    "'use strict';\n\nvar extend = require('./lib/extend');\nvar createUID = require('./lib/createUID');\n\nfunction applyMixins (mixins, instance) {\n  var mixin;\n  while (mixins.length) {\n    mixin = mixins.shift();\n    (typeof mixin.applyTo === 'function') &&\n      mixin.applyTo(instance);\n  }\n}\n\nfunction extendSelf (staticProps) {\n  /* jshint validthis:true */\n\n  staticProps = staticProps || {};\n\n  // extend from the base singleton\n  var BaseSingleton = this || WBSingleton;\n\n  // create a new instance\n  Ctor.prototype = BaseSingleton;\n  var singleton = new Ctor();\n\n  // extract mixins\n  var mixins = staticProps.mixins || [];\n  staticProps.mixins = undefined;\n\n  // apply mixins to the instance\n  applyMixins(mixins, singleton);\n\n  // append the static properties to the singleton\n  extend(singleton, staticProps);\n\n  // make the singleton extendable\n  // Do this after applying mixins,\n  // to ensure that no mixin can override `extend` method\n  singleton.extend = extendSelf;\n\n  // every signleton gets a UID\n  singleton.uid = createUID();\n\n  return singleton;\n}\n\nvar Ctor = function () {};\nCtor.prototype = {\n  'extend': extendSelf\n};\n\nvar WBSingleton = new Ctor();\nmodule.exports = WBSingleton;\n",
    "'use strict';\n\nvar WBClass = require('./WBClass');\n\nvar WBDestroyableMixin = require('./mixins/WBDestroyableMixin');\nvar originalDestroy = WBDestroyableMixin.Behavior.destroy;\n\nvar WBStateModel = WBClass.extend({\n\n  'mixins': [\n    require('./mixins/WBEventsMixin'),\n    require('./mixins/WBStateMixin'),\n    require('./mixins/WBBindableMixin'),\n    WBDestroyableMixin\n  ],\n\n  'initialize': function (attributes) {\n\n    var self = this;\n\n    if (attributes) {\n      self.attributes = attributes;\n    }\n  },\n\n  'sync':  function (method, instance, options) {\n    if (options && typeof options.success === 'function') {\n      options.success();\n    }\n  },\n\n  'fetch': function (options) {\n    var self = this;\n    var success = options.success;\n    var model = this;\n    options.success = function (resp) {\n      if (!model.set(resp, options)) return false;\n      if (success) success(model, resp, options);\n      model.trigger('sync', model, resp, options);\n    };\n    return self.sync('read', self, options);\n  },\n\n  'save': function (key, val, options) {\n\n    var self = this;\n    if (!self.destroying) {\n      // set the attributes\n      self.set(key, val, options);\n      // sync\n      (typeof key === 'object') && (options = val);\n      self.sync('update', self, options);\n    }\n    return self;\n  },\n\n  'destroy': function (options) {\n\n    var self = this;\n    if (!self.destroying) {\n      self.destroying = true;\n      originalDestroy.call(self, options);\n      self.attributes = {};\n      self.sync('delete', self, options);\n    }\n  }\n});\n\nmodule.exports = WBStateModel;\n",
    "'use strict';\n\nmodule.exports = {\n  'lib': require('./lib'),\n  'BaseEventEmitter': require('./BaseEventEmitter'),\n  'BaseSingleton': require('./BaseSingleton'),\n  'WBClass': require('./WBClass'),\n  'WBDeferred': require('./WBDeferred'),\n  'WBEventEmitter': require('./WBEventEmitter'),\n  'WBMixin': require('./WBMixin'),\n  'WBSingleton': require('./WBSingleton'),\n  'WBStateModel': require('./WBStateModel'),\n  'mixins': require('./mixins')\n};\n",
    "'use strict';\n\nfunction assert (condition, message) {\n  if (!condition) {\n    throw new Error(message || '');\n  }\n}\n\nvar nativeIsArray = Array.isArray;\nassert.empty = function (object, message) {\n  var keys = nativeIsArray(object) ? object : Object.keys(object);\n  assert(keys.length === 0, message);\n};\n\nassert.array = function (array, message) {\n  assert(nativeIsArray(array), message);\n};\n\nassert.class = function (klass, message) {\n  var proto = klass.prototype;\n  assert(proto && proto.constructor === klass, message);\n};\n\nvar types = [\n  'undefined',\n  'boolean',\n  'number',\n  'string',\n  'function',\n  'object'\n];\n\nfunction typecheck (type) {\n  assert[type] = function (o, message) {\n    assert(typeof o === type, message);\n  };\n}\n\nwhile (types.length) {\n  typecheck(types.shift());\n}\n\nmodule.exports = assert;\n",
    "'use strict';\n\nvar nativeIsArray = Array.isArray;\n\nfunction cloneArray (arr, isDeep) {\n  arr = arr.slice();\n  if (isDeep) {\n    var newArr = [], value;\n    while (arr.length) {\n      value = arr.shift();\n      value = (value instanceof Object) ? clone(value, isDeep) : value;\n      newArr.push(value);\n    }\n    arr = newArr;\n  }\n  return arr;\n}\n\nfunction cloneDate (date) {\n  return new Date(date.getTime());\n}\n\nfunction cloneObject (source, isDeep) {\n  var object = {};\n  for (var key in source) {\n    if (source.hasOwnProperty(key)) {\n      var value = source[key];\n      if (value instanceof Date) {\n        object[key] = cloneDate(value);\n      } else if (typeof value === 'object' && value !== null && isDeep) {\n        object[key] = clone(value, isDeep);\n      } else {\n        object[key] = value;\n      }\n    }\n  }\n  return object;\n}\n\nfunction clone (obj, isDeep) {\n\n  if (nativeIsArray(obj)) {\n    return cloneArray(obj, isDeep);\n  }\n\n  return cloneObject(obj, isDeep);\n}\n\nmodule.exports = clone;\n",
    "// http://stackoverflow.com/a/21963136/933653\n'use strict';\n\nvar ff = 0xff;\nvar lut = [];\nfor (var i = 0; i < 256; i++) {\n  lut[i] = (i < 16 ? '0' : '') + (i).toString(16);\n}\n\nvar random = Math.random;\nfunction randHex() {\n  return (random() * 0xffffffff | 0);\n}\n\nfunction section0 () {\n  var d0 = randHex();\n  return lut[d0 & ff] + lut[d0 >> 8 & ff] +\n           lut[d0 >> 16 & ff] + lut[d0 >> 24 & ff];\n}\n\nfunction section1 () {\n  var d1 = randHex();\n  return lut[d1 & ff] + lut[d1 >> 8 & ff] + '-' +\n         lut[d1 >> 16 & 0x0f | 0x40] + lut[d1 >> 24 & ff];\n}\n\nfunction section2 () {\n  var d2 = randHex();\n  return lut[d2 & 0x3f | 0x80] + lut[d2 >> 8 & ff] + '-' +\n       lut[d2 >> 16 & ff] + lut[d2 >> 24 & ff];\n}\n\nfunction section3 () {\n  var d3 = randHex();\n  return lut[d3 & ff] + lut[d3 >> 8 & ff] +\n       lut[d3 >> 16 & ff] + lut[d3 >> 24 & ff];\n}\n\nfunction createUID (prefix) {\n  var uid = [section0(), section1(), section2(), section3()].join('-');\n  return (!prefix ? '' : prefix).toString() + uid;\n}\n\nmodule.exports = createUID;\n",
    "'use strict';\n\n// Returns a function, that, as long as it continues to be invoked, will not\n// be triggered. The function will be called after it stops being called for\n// N milliseconds. If `immediate` is passed, trigger the function on the\n// leading edge, instead of the trailing.\n// From: http://davidwalsh.name/function-debounce\nfunction debounce (fn, wait, immediate) {\n  var timeout;\n  return function() {\n    var context = this, args = arguments;\n    var later = function() {\n      timeout = null;\n      if (!immediate) {\n        fn.apply(context, args);\n      }\n    };\n    var callNow = immediate && !timeout;\n    clearTimeout(timeout);\n    timeout = setTimeout(later, wait);\n    if (callNow) {\n      fn.apply(context, args);\n    }\n  };\n}\n\nmodule.exports = debounce;",
    "'use strict';\n\nvar toArray = require('./toArray');\nvar delay = require('./delay');\n\nfunction defer (fn) {\n  var args = toArray(arguments);\n  args[0] = 1;\n  args.unshift(fn);\n  return delay.apply(null, args);\n}\n\nmodule.exports = defer;\n",
    "'use strict';\n\nvar toArray = require('./toArray');\n\nfunction delay (fn, time, context) {\n  var args = toArray(arguments, 3);\n  return setTimeout(function () {\n\n    var destroyed = context && context.destroyed;\n    !destroyed && fn.apply(context, args);\n  }, time);\n}\n\nmodule.exports = delay;\n",
    "'use strict';\n\nvar assert = require('./assert');\nvar toArray = require('./toArray');\nvar clone = require('./clone');\n\nvar eventSplitter = /\\s+/;\n\nvar validationErrors = {\n  'trigger': 'Cannot trigger event(s) without event name(s)',\n  'events': 'Cannot bind/unbind without valid event name(s)',\n  'callback': 'Cannot bind/unbind to an event without valid callback function'\n};\n\nvar events = {\n\n  'properties': {\n    '_events': {},\n    '_cache': {}\n  },\n\n  'on': function (events, callback, context) {\n\n    var self = this;\n\n    // validate arguments\n    assert.string(events, validationErrors.events);\n    assert.function(callback, validationErrors.callback);\n\n    // loop through the events & bind them\n    self.iterate(events, function (name) {\n      // keep the binding\n      self.bind(name, callback, context);\n\n      // if this was a published event, do an immediate trigger\n      var cache = self._cache;\n      if (cache[name]) {\n        callback.apply(context || self, cache[name]);\n      }\n    });\n\n    return self;\n  },\n\n  'off': function (events, callback, context) {\n\n    var self = this;\n\n    // validate events only if a truthy value is passed\n    events && assert.string(events, validationErrors.events);\n\n    // if no arguments were passed, unbind everything\n    if (!events && !callback && !context) {\n      self._events = {};\n      return self;\n    }\n\n    // if no events are passed, unbind all events with this callback\n    events = events || Object.keys(self._events);\n\n    // loop through the events & bind them\n    self.iterate(events, function (name) {\n      self.unbind(name, callback, context);\n    });\n\n    return self;\n  },\n\n  'once': function (events, callback, context) {\n\n    var self = this;\n    var args = toArray(arguments);\n\n    // create a one time binding\n    args[1] = function () {\n      self.off.apply(self, args);\n      callback.apply(context || self, arguments);\n    };\n\n    self.on.apply(self, args);\n\n    return self;\n  },\n\n  'publish': function (events) {\n\n    var self = this;\n    var args = toArray(arguments);\n\n    // validate events\n    assert.string(events, validationErrors.events);\n\n    self.iterate(events, function (name) {\n      var cache = self._cache;\n      if (!cache[name]) {\n        cache[name] = args.slice(1);\n        args[0] = name;\n        self.trigger.apply(self, args);\n      }\n    });\n\n    return self;\n  },\n\n  'unpublish': function (events) {\n\n    var self = this;\n\n    // validate events\n    assert.string(events, validationErrors.events);\n\n    // remove the cache for the events\n    self.iterate(events, function (name) {\n      self._cache[name] = undefined;\n    });\n\n    return self;\n  },\n\n  'unpublishAll': function () {\n    var self = this;\n    self._cache = {};\n    return self;\n  },\n\n  'trigger': function (events) {\n\n    var self = this;\n\n    // validate arguments\n    assert.string(events, validationErrors.trigger);\n\n    // loop through the events & trigger them\n    var params = toArray(arguments, 1);\n    self.iterate(events, function (name) {\n      self.triggerEvent(name, params);\n    });\n\n    return self;\n  },\n\n  'triggerEvent': function (name, params) {\n\n    var self = this;\n    var events = self._events || {};\n\n    // call sub-event handlers\n    var current = [];\n    var fragments = name.split(':');\n    while (fragments.length) {\n      current.push(fragments.shift());\n      name = current.join(':');\n      if (name in events) {\n        self.triggerSection(name, fragments, params);\n      }\n    }\n  },\n\n  'triggerSection': function (name, fragments, params) {\n\n    var self = this;\n    var events = self._events || {};\n    var bucket = events[name] || [];\n\n    bucket.forEach(function (item) {\n      var args;\n      if (fragments.length) {\n        args = clone(params);\n        args.unshift(fragments);\n      }\n      item.callback.apply(item.context || self, args || params);\n    });\n  },\n\n  'iterate': function (events, iterator) {\n\n    var self = this;\n\n    if (typeof events === 'string') {\n      events = events.split(eventSplitter);\n    } else {\n      assert.array(events);\n    }\n\n    while (events.length) {\n      iterator.call(self, events.shift());\n    }\n  },\n\n  'bind': function (name, callback, context) {\n\n    var self = this;\n\n    // store the reference to the callback + context\n    var events = self._events || {};\n    var bucket = events[name] || (events[name] = []);\n    bucket.push({\n      'callback': callback,\n      'context': context\n    });\n\n    return self;\n  },\n\n  'unbind': function (name, callback, context) {\n\n    var self = this;\n\n    // lookup the reference to handler & remove it\n    var events = self._events;\n    var bucket = events[name] || [];\n    var retain = [];\n\n    // loop through the handlers\n    var i = -1, l = bucket.length, item;\n    while (++i < l) {\n      item = bucket[i];\n      if ((callback && callback !== item.callback) ||\n          (context && context !== item.context)) {\n        retain.push(item);\n      }\n    }\n\n    // flush out detached handlers\n    events[name] = retain;\n\n    return self;\n  }\n};\n\nmodule.exports = events;\n",
    "'use strict';\n\nvar toArray = require('./toArray');\nvar merge = require('./merge');\nvar assert = require('./assert');\n\nfunction extend () {\n\n  // convert the argument list into an array\n  var args = toArray(arguments);\n\n  // validate input\n  assert(args.length > 0, 'extend expect one or more objects');\n\n  // loop through the arguments\n  // & merging them recursively\n  var object = args.shift();\n  while (args.length) {\n    merge(object, args.shift());\n  }\n\n  return object;\n}\n\nmodule.exports = extend;\n",
    "'use strict';\n\nfunction forArray (array, iterator, context) {\n  for (var i = 0, l = array.length; i < l; i++) {\n    if (iterator.call(context, array[i], i, array) === false) {\n      return;\n    }\n  }\n}\n\nfunction forObject (object, iterator, context) {\n  for (var key in object) {\n    if (object.hasOwnProperty(key)) {\n      if (iterator.call(context, object[key], key) === false) {\n        return;\n      }\n    }\n  }\n}\n\nfunction forEach (collection, iterator, context) {\n  var handler = Array.isArray(collection) ? forArray : forObject;\n  handler(collection, iterator, context);\n}\n\nmodule.exports = forEach;\n",
    "'use strict';\n\nvar merge = require('./merge');\nvar extend = require('./extend');\n\nfunction mergeFromSuper (instance, key) {\n\n  var constructor = instance.constructor;\n  var proto = constructor.prototype;\n\n  var baseData = {};\n  if (instance.hasOwnProperty(key)) {\n    baseData = instance[key];\n  } else if (proto.hasOwnProperty(key)) {\n    baseData = proto[key];\n  }\n\n  var _super = constructor && constructor.__super__;\n  if (_super) {\n    baseData = merge(mergeFromSuper(_super, key), baseData);\n  }\n\n  return extend({}, baseData);\n}\n\nfunction concatFromSuper (instance, key) {\n\n  var constructor = instance.constructor;\n  var proto = constructor.prototype;\n\n  var baseData = [];\n  if (instance.hasOwnProperty(key)) {\n    baseData = instance[key];\n  } else if (proto.hasOwnProperty(key)) {\n    baseData = proto[key];\n  }\n\n  var _super = constructor && constructor.__super__;\n  if (_super) {\n    baseData = [].concat(concatFromSuper(_super, key), baseData);\n  }\n\n  return [].concat(baseData);\n}\n\nmodule.exports = {\n  'merge': mergeFromSuper,\n  'concat': concatFromSuper\n};\n",
    "'use strict';\n\nfunction functions (obj) {\n  var funcs = [];\n  for (var key in obj) {\n    if (typeof obj[key] === 'function') {\n      funcs.push(key);\n    }\n  }\n  return funcs;\n}\n\nmodule.exports = functions;\n",
    "'use strict';\n\nmodule.exports = {\n  'assert': require('./assert'),\n  'clone': require('./clone'),\n  'createUID': require('./createUID'),\n  'debounce': require('./debounce'),\n  'defer': require('./defer'),\n  'delay': require('./delay'),\n  'events': require('./events'),\n  'extend': require('./extend'),\n  'forEach': require('./forEach'),\n  'fromSuper': require('./fromSuper'),\n  'functions': require('./functions'),\n  'inherits': require('./inherits'),\n  'isEqual': require('./isEqual'),\n  'merge': require('./merge'),\n  'size': require('./size'),\n  'toArray': require('./toArray'),\n  'when': require('./when'),\n  'where': require('./where')\n};",
    "'use strict';\n\nvar extend = require('./extend');\n\n// Helper function to correctly set up the prototype chain, for subclasses.\n// Similar to `goog.inherits`, but uses a hash of prototype properties and\n// class properties to be extended.\nfunction inherits (parent, protoProps, staticProps) {\n\n  var child;\n\n  // The constructor function for the new subclass is either defined by you\n  // (the \"constructor\" property in your `extend` definition), or defaulted\n  // by us to simply call `super()`.\n  if (protoProps && protoProps.hasOwnProperty('constructor')) {\n    child = protoProps.constructor;\n  }\n  else {\n    child = function () {\n      return parent.apply(this, arguments);\n    };\n  }\n\n  // Inherit class (static) properties from parent.\n  extend(child, parent);\n\n  // Set the prototype chain to inherit from `parent`, without calling\n  // `parent`'s constructor function.\n  child.prototype = Object.create(parent.prototype);\n\n  // Add prototype properties (instance properties) to the subclass,\n  // if supplied.\n  extend(child.prototype, protoProps);\n\n  // Correctly set child's `prototype.constructor`.\n  child.prototype.constructor = child;\n\n  // Add static properties to the constructor function, if supplied.\n  extend(child, staticProps);\n\n  // Set a convenience property\n  // in case the parent's prototype is needed later.\n  child.__super__ = parent.prototype;\n\n  return child;\n}\n\nmodule.exports = inherits;\n",
    "'use strict';\n\n// TODO: implement deepEqual\nfunction isEqual (a, b) {\n  return a === b;\n}\n\nmodule.exports = isEqual;\n",
    "'use strict';\n\nvar toArray = require('./toArray');\n\nfunction merge (object, source) {\n  var sources = toArray(arguments, 1);\n  while (sources.length) {\n    source = sources.shift();\n    for (var key in source) {\n      if (source.hasOwnProperty(key)) {\n        object[key] = source[key];\n      }\n    }\n  }\n  return object;\n}\n\nmodule.exports = merge;\n",
    "'use strict';\n\nfunction size (collection) {\n  !Array.isArray(collection) && (collection = Object.keys(collection));\n  return collection.length;\n}\n\nmodule.exports = size;\n",
    "'use strict';\n\nfunction getAllocatedArray (arrLength) {\n\n  arrLength = arrLength > 0 ? arrLength : 0;\n  return new Array(arrLength);\n}\n\nfunction toArray (arrayLikeObj, skip) {\n\n  skip = skip || 0;\n\n  var length = arrayLikeObj.length;\n  var arr = getAllocatedArray(length - skip);\n\n  for (var i = skip; i < length; i++) {\n    arr[i - skip] = arrayLikeObj[i];\n  }\n\n  return arr;\n}\n\nmodule.exports = toArray;",
    "'use strict';\n\nvar WBDeferred = require('../WBDeferred');\nvar toArray = require('./toArray');\n\nfunction When () {\n\n  var context = this;\n  var main = new WBDeferred(context);\n  var deferreds = toArray(arguments);\n\n  // support passing an array of deferreds, to avoid `apply`\n  if (deferreds.length === 1 && Array.isArray(deferreds[0])) {\n    deferreds = deferreds[0];\n  }\n\n  var count = deferreds.length;\n  var args = new Array(count);\n\n  function Fail () {\n    main.rejectWith(this);\n  }\n\n  function Done () {\n\n    if (main.state() === 'rejected') {\n      return;\n    }\n\n    var index = count - deferreds.length - 1;\n    args[index] = toArray(arguments);\n\n    if (deferreds.length) {\n      var next = deferreds.shift();\n      next.done(Done);\n    } else {\n      args.unshift(this);\n      main.resolveWith.apply(main, args);\n    }\n  }\n\n  if (deferreds.length) {\n\n    deferreds.forEach(function (deferred) {\n      deferred.fail(Fail);\n    });\n\n    var current = deferreds.shift();\n    current.done(Done);\n  } else {\n    main.resolve();\n  }\n\n  return main.promise();\n}\n\nmodule.exports = When;\n",
    "'use strict';\n\nvar forEach = require('./forEach');\n\nfunction where (collection, properties) {\n  var matches = [];\n  forEach(collection, function (item) {\n    for (var key in properties) {\n      if (item[key] !== properties[key]) {\n        return;\n      }\n      matches.push(item);\n    }\n  });\n  return matches;\n}\n\nmodule.exports = where;\n",
    "'use strict';\n\nvar WBMixin = require('../WBMixin');\nvar fromSuper = require('../lib/fromSuper');\n\nvar ControllableMixin = WBMixin.extend({\n\n  'initialize': function () {\n\n    var self = this;\n\n    self.controllers = [];\n    self.implemented = [];\n\n    self.implements = fromSuper.concat(self, 'implements');\n    self.createControllerInstances();\n\n    self.bindOnceTo(self, 'destroy', 'destroyControllers');\n  },\n\n  'createControllerInstances': function () {\n\n    var self = this;\n\n    var Controllers = self.implements;\n    if (typeof Controllers === 'function') {\n      Controllers = Controllers.call(self);\n    }\n\n    var ControllerClass, controllerInstance, i;\n\n    // the order in which the controllers are implemented is important!\n    for (i = Controllers.length; i--;) {\n      ControllerClass = Controllers[i];\n\n      // If we have already implemented a controller that inherits from\n      // this controller, we don't need another one...\n      if (self.implemented.indexOf(ControllerClass.toString()) < 0) {\n\n        controllerInstance = new ControllerClass(self);\n        self.controllers.push(controllerInstance);\n        controllerInstance.parent = self;\n\n        self.trackImplementedSuperConstructors(ControllerClass);\n      }\n    }\n\n    return self.implemented;\n  },\n\n  'trackImplementedSuperConstructors': function (Controller) {\n\n    var self = this;\n    var _super = Controller.__super__;\n    var superConstructor = _super && _super.constructor;\n\n    if (superConstructor) {\n      self.implemented.push(superConstructor.toString());\n      self.trackImplementedSuperConstructors(superConstructor);\n    }\n  },\n\n  'destroyControllers': function () {\n\n    var self = this;\n\n    // Loop and destroy\n    var controller;\n    var controllers = self.controllers;\n\n    while (controllers.length) {\n      // A controller can exist multiple times in the list,\n      // since it's based on the event name,\n      // so make sure to only destroy each one once\n      controller = controllers.shift();\n      controller.destroyed || controller.destroy();\n    }\n  }\n});\n\nmodule.exports = ControllableMixin;\n",
    "'use strict';\n\nvar WBMixin = require('../WBMixin');\nvar fromSuper = require('../lib/fromSuper');\nvar clone = require('../lib/clone');\n\nvar ObservableHashMixin = WBMixin.extend({\n\n  'initialize': function () {\n\n    var self = this;\n\n    var observesHash = fromSuper.merge(self, 'observes');\n    for (var target in observesHash) {\n      self.bindToTarget(self.resolveTarget(target), observesHash[target]);\n    }\n  },\n\n  'bindToTarget': function (target, events) {\n\n    var self = this;\n\n    for (var eventString in events) {\n      self.bindHandlers(target, eventString, events[eventString]);\n    }\n  },\n\n  'bindHandlers': function (target, eventString, handlers) {\n\n    var self = this;\n\n    if (typeof handlers === 'string') {\n      handlers = [handlers];\n    } else {\n      handlers = clone(handlers);\n    }\n\n    while (handlers.length) {\n      self.bindTo(target, eventString, handlers.shift());\n    }\n  },\n\n  'resolveTarget': function (key) {\n\n    var self = this;\n\n    // allow observing self\n    if (key === 'self') {\n      return self;\n    }\n\n    var target = self[key];\n    if (!target && typeof key === 'string' && key.indexOf('.') > -1) {\n      key = key.split('.');\n      target = self;\n      while (key.length && target) {\n        target = target[key.shift()];\n      }\n    }\n\n    return target;\n  }\n\n});\n\nmodule.exports = ObservableHashMixin;\n",
    "'use strict';\n\nvar WBMixin = require('../WBMixin');\n// var assert = require('../lib/assert');\nvar createUID = require('../lib/createUID');\n\nvar WBBindableMixin = WBMixin.extend({\n\n  'properties': {\n    '_bindings': {},\n    '_namedEvents': {}\n  },\n\n  // keeps callback closure in own execution context with\n  // only callback and context\n  'callbackFactory': function  (callback, context) {\n\n    var bindCallback;\n\n    var forString = function stringCallback () {\n      context[callback].apply(context, arguments);\n    };\n\n    var forFunction = function functionCallback () {\n      callback.apply(context, arguments);\n    };\n\n    if (typeof callback === 'string') {\n      bindCallback = forString;\n      // cancel alternate closure immediately\n      forFunction = null;\n    }\n    else {\n      bindCallback = forFunction;\n      forString = null;\n    }\n\n    return bindCallback;\n  },\n\n  'bindTo': function (target, event, callback, context) {\n\n    var self = this;\n    self.checkBindingArgs.apply(self, arguments);\n\n    // default to self if context not provided\n    context = context || self;\n\n    // if this binding already made, return it\n    var bound = self.isAlreadyBound(target, event, callback, context);\n    if (bound) {\n      return bound;\n    }\n\n\n    var callbackFunc, args;\n\n    // if a jquery object\n    if (target.constructor && target.constructor.fn && target.constructor.fn.on === target.on) {\n      // jquery does not take context in .on()\n      // cannot assume on takes context as a param for bindable object\n      // create a callback which will apply the original callback in the correct context\n      callbackFunc = self.callbackFactory(callback, context);\n      args = [event, callbackFunc];\n    } else {\n      // Backbone accepts context when binding, simply pass it on\n      callbackFunc = (typeof callback === 'string') ? context[callback] : callback;\n      args = [event, callbackFunc, context];\n    }\n\n    // create binding on target\n    target.on.apply(target, args);\n\n    var binding = {\n      'uid': createUID(),\n      'target': target,\n      'event': event,\n      'originalCallback': callback,\n      'callback': callbackFunc,\n      'context': context\n    };\n\n    self._bindings[binding.uid] = binding;\n    self.addToNamedBindings(event, binding);\n\n    return binding;\n  },\n\n  'bindOnceTo': function (target, event, callback, context) {\n\n    var self = this;\n    self.checkBindingArgs.apply(self, arguments);\n\n    context = context || self;\n\n    // if this binding already made, return it\n    var bound = self.isAlreadyBound(target, event, callback, context);\n    if (bound) {\n      return bound;\n    }\n\n\n    // this is a wrapper\n    var onceBinding = function () {\n\n      ((typeof callback === 'string') ? context[callback] : callback).apply(context, arguments);\n      self.unbindFrom(binding);\n    };\n\n    var binding = {\n      'uid': createUID(),\n      'target': target,\n      'event': event,\n      'originalCallback': callback,\n      'callback': onceBinding,\n      'context': context\n    };\n\n    target.on(event, onceBinding, context);\n\n    self._bindings[binding.uid] = binding;\n    self.addToNamedBindings(event, binding);\n\n    return binding;\n  },\n\n  'unbindFrom': function (binding) {\n\n    var self = this;\n\n    var uid = binding && binding.uid;\n    if (!binding || (typeof uid !== 'string')) {\n      throw new Error('Cannot unbind from undefined or invalid binding');\n    }\n\n    var event = binding.event;\n    var context = binding.context;\n    var callback = binding.callback;\n    var target = binding.target;\n\n    // a binding object with only uid, i.e. a destroyed/unbound\n    // binding object has been passed - just do nothing\n    if (!event || !callback || !target || !context) {\n      return;\n    }\n\n    target.off(event, callback, context);\n\n    // clean up binding object, but keep uid to\n    // make sure old bindings, that have already been\n    // cleaned, are still recognized as bindings\n    for (var key in binding) {\n      if (key !== 'uid') {\n        delete binding[key];\n      }\n    }\n\n    delete self._bindings[uid];\n\n    var namedEvents = self._namedEvents;\n    var events = namedEvents[event];\n\n    if (events) {\n      var cloned = events && events.slice(0);\n      for (var i = events.length - 1; i >= 0; i--) {\n        if (events[i].uid === uid) {\n          cloned.splice(i, 1);\n        }\n      }\n\n      namedEvents[event] = cloned;\n    }\n\n    return;\n  },\n\n  'unbindFromTarget': function (target) {\n\n    var self = this;\n\n    if (!target || (typeof target.on !== 'function')) {\n      throw new Error('Cannot unbind from undefined or invalid binding target');\n    }\n\n    var binding;\n    for (var key in self._bindings) {\n      binding = self._bindings[key];\n      if (binding.target === target) {\n        self.unbindFrom(binding);\n      }\n    }\n  },\n\n  'unbindAll': function () {\n\n    var self = this;\n\n    var binding;\n    for (var key in self._bindings) {\n      binding = self._bindings[key];\n      self.unbindFrom(binding);\n    }\n  },\n\n  'checkBindingArgs': function (target, event, callback, context) {\n\n    context = context || this;\n\n    // do not change these messages without updating the specs\n    if (!target || (typeof target.on !== 'function')) {\n      throw new Error('Cannot bind to undefined target or target without #on method');\n    }\n\n    if (!event || (typeof event !== 'string')) {\n      throw new Error('Cannot bind to target event without event name');\n    }\n\n    if (!callback || ((typeof callback !== 'function') && (typeof callback !== 'string'))) {\n      throw new Error('Cannot bind to target event without a function or method name as callback');\n    }\n\n    if ((typeof callback === 'string') && !context[callback]) {\n      throw new Error('Cannot bind to target using a method name that does not exist for the context');\n    }\n  },\n\n  'isAlreadyBound': function (target, event, callback, context) {\n\n    var self = this;\n    // check for same callback on the same target instance\n    // return early withthe event binding\n    var events = self._namedEvents[event];\n    if (events) {\n      for (var i = 0, max = events.length; i < max; i++) {\n\n        var current = events[i] || {};\n\n        // the below !boundTarget check seems unreachable\n        // was added in this commit of the web app: c75d5077c0a8629b60cb6dd1cd78d3bc77fcac48\n        // need to ask Adam under what conditions this would be possible\n        var boundTarget = current.target;\n        if (!boundTarget) {\n          return false;\n        }\n\n        var targetBound = target.uid ? target.uid === boundTarget.uid : false;\n        if (current.originalCallback === callback &&\n            current.context === context && targetBound) {\n          return current;\n        }\n      }\n    }\n\n    return false;\n  },\n\n  'addToNamedBindings': function (event, binding) {\n\n    var self = this;\n    if (!self._namedEvents[event]) {\n      self._namedEvents[event] = [];\n    }\n    self._namedEvents[event].push(binding);\n  }\n});\n\nmodule.exports = WBBindableMixin;\n",
    "'use strict';\n\nvar forEach = require('../lib/forEach');\nvar WBMixin = require('../WBMixin');\n\nfunction noop () {}\n\nfunction Call (fn) {\n  var self = this;\n  (typeof fn === 'string') && (fn = self[fn]);\n  (typeof fn === 'function') && fn.call(self);\n}\n\nvar cleanupMethods = ['unbind', 'unbindAll', 'onDestroy'];\n\nvar WBDestroyableMixin = WBMixin.extend({\n\n  'destroy': function () {\n\n    var self = this;\n\n    self.trigger('destroy');\n\n    // clean up\n    forEach(cleanupMethods, Call, self);\n\n    self.destroyObject(self);\n\n    self.destroyed = true;\n  },\n\n  'destroyObject': function (object) {\n\n    var self = this;\n    for (var key in object) {\n      self.destroyKey(key, object);\n    }\n  },\n\n  'destroyKey': function (key, context) {\n\n    if (context.hasOwnProperty(key) && key !== 'uid' && key !== 'cid') {\n      // make functions noop\n      if (typeof context[key] === 'function') {\n        context[key] = noop;\n      }\n      // and others undefined\n      else {\n        context[key] = undefined;\n      }\n    }\n  }\n});\n\nmodule.exports = WBDestroyableMixin;\n",
    "'use strict';\n\nvar WBMixin = require('../WBMixin');\nvar events = require('../lib/events');\n\nvar WBEventsMixin = WBMixin.extend(events);\n\nmodule.exports = WBEventsMixin;\n",
    "'use strict';\n\nvar clone = require('../lib/clone');\nvar merge = require('../lib/merge');\nvar extend = require('../lib/extend');\nvar isEqual = require('../lib/isEqual');\nvar WBMixin = require('../WBMixin');\n\nvar WBStateMixin = WBMixin.extend({\n\n  'attributes': {},\n  'options': {},\n\n  'initialize': function (attributes, options) {\n\n    var self = this;\n    self.attributes = extend({}, self.defaults, attributes);\n    self.options = options || {};\n    self.changed = {};\n  },\n\n  'get': function (key) {\n    console.warn('getters are deprecated');\n    return this.attributes[key];\n  },\n\n  'set': function (key, val, options) {\n\n    var self = this;\n    if (key === null) {\n      return self;\n    }\n\n    var attrs, attr;\n    // Handle both `\"key\", value` and `{key: value}` -style arguments.\n    if (typeof key === 'object') {\n      attrs = key;\n      options = val;\n    } else {\n      attrs = {};\n      attrs[key] = val;\n    }\n\n    // default options are empty\n    options || (options = {});\n\n    // no need to track changes on options.silent\n    if (options.silent) {\n      merge(self.attributes, attr);\n    }\n    // For each `set` attribute, update or delete the current value.\n    else {\n      var changes = self.changes(attrs, options);\n      self._trigger(attrs, changes, options);\n    }\n\n    return self;\n  },\n\n  'unset': function (attr, options) {\n    return this.set(attr, undefined, extend({}, options, { 'unset': true }));\n  },\n\n  'clear': function (options) {\n    var self = this;\n    return self.set(self.defaults, options);\n  },\n\n  'changes': function (attrs, options) {\n\n    var self = this;\n    var key, val;\n    var changes = [];\n\n    var prev = clone(self.attributes, true);\n    var current = self.attributes;\n    self.changed = {};\n\n    for (key in attrs) {\n      val = attrs[key];\n      if (!isEqual(current[key], val)) {\n        changes.push(key);\n      }\n      if (!isEqual(prev[key], val)) {\n        self.changed[key] = val;\n      } else {\n        delete self.changed[key];\n      }\n\n      current[key] = options.unset ? undefined : val;\n    }\n\n    return changes;\n  },\n\n  '_trigger': function (attrs, changes, options) {\n\n    var self = this;\n    var current = self.attributes;\n\n    // if any changes found\n    // & if this is an EventEmitter,\n    // trigger the change events\n    var attr;\n    while (changes && changes.length && self.trigger) {\n      attr = changes.shift();\n      self.trigger('change:' + attr, self, current[attr], options);\n    }\n  }\n});\n\nmodule.exports = WBStateMixin;\n",
    "'use strict';\n\nvar WBMixin = require('../WBMixin');\nvar WBDeferred = require('../WBDeferred');\nvar when = require('../lib/when');\nvar toArray = require('../lib/toArray');\nvar forEach = require('../lib/forEach');\nvar delay = require('../lib/delay');\nvar defer = require('../lib/defer');\nvar functions = require('../lib/functions');\n\nvar WBUtilsMixin = WBMixin.extend({\n\n  'deferred': function () {\n    var self = this;\n    return new WBDeferred(self);\n  },\n\n  'when': function () {\n    var self = this;\n    return when.apply(self, arguments);\n  },\n\n  'defer': function (fn) {\n    var self = this;\n    var args = toArray(arguments);\n    // default context to self\n    args[1] = args[1] || this;\n    // support string names of functions on self\n    (typeof fn === 'string') && (args[0] = self[fn]);\n    return defer.apply(null, args);\n  },\n\n  'delay': function (fn) {\n    var self = this;\n    var args = toArray(arguments);\n    // default context to self\n    args[2] = args[2] || self;\n    // support string names of functions on self\n    (typeof fn === 'string') && (args[0] = self[fn]);\n    return delay.apply(null, args);\n  },\n\n  'forEach': function (collection, fn, context) {\n    var self = this;\n    // default context to self\n    context = context || self;\n    // support string names of functions on self\n    (typeof fn === 'string') && (fn = self[fn]);\n    forEach(collection, fn, context);\n  },\n\n  'functions': function (obj) {\n    return functions(obj || this);\n  }\n});\n\nmodule.exports = WBUtilsMixin;\n",
    "'use strict';\n\nmodule.exports = {\n  'ControllableMixin': require('./ControllableMixin'),\n  'ObservableHashMixin': require('./ObservableHashMixin'),\n  'WBBindableMixin': require('./WBBindableMixin'),\n  'WBDestroyableMixin': require('./WBDestroyableMixin'),\n  'WBEventsMixin': require('./WBEventsMixin'),\n  'WBStateMixin': require('./WBStateMixin'),\n  'WBUtilsMixin': require('./WBUtilsMixin')\n};",
    "'use strict';\n\nvar core = require('wunderbits.core');\nvar WBEventEmitter = core.WBEventEmitter;\nvar clone = core.lib.clone;\nvar assert = core.lib.assert;\n\nvar generateId = require('./lib/generateId');\n\n// Default id Attribute used\nvar defaultKeyPath = 'id';\n\nvar BackboneDBSync = WBEventEmitter.extend({\n\n  'initialize': function (options) {\n\n    var self = this;\n    assert.object(options);\n    assert(options.database);\n\n    self.database = options.database;\n  },\n\n  'generateId': function (keyPath, id, instance) {\n\n    if (!id) {\n      id = generateId();\n      if (instance.collection) {\n        while (instance.collection.get(id)) {\n          id = generateId();\n        }\n      }\n      instance.set(keyPath, id);\n    }\n\n    return id;\n  },\n\n  'queryCollection': function (collection) {\n\n    var self = this;\n    var crud = self.database.crud;\n    var storeName = collection.storeName || collection.model.prototype.storeName;\n    return crud.query(storeName);\n  },\n\n  'operateOnModel': function (model, method) {\n\n    var self = this;\n    var crud = self.database.crud;\n    var json;\n    if (typeof model.toJSON === 'function') {\n      json = model.toJSON();\n    }\n    else {\n      json = clone(model.attributes);\n    }\n    json.id || (json.id = model.id);\n    return crud[method](model.storeName, json);\n  },\n\n  'sync': function (method, instance, options) {\n\n    var self = this;\n    options = options || {};\n\n    var stores = self.database.stores;\n\n    var collection = instance.collection;\n    var storeName = instance.storeName || (collection && collection.storeName);\n    var storeInfo = stores[storeName];\n    var keyPath = (storeInfo && storeInfo.keyPath) || defaultKeyPath;\n    var attributes = instance.attributes;\n    var id = attributes.id || attributes[keyPath];\n    var isAWrite = /(create|update)/.test(method);\n\n    // Assign IDs automatically if not present\n    if (isAWrite) {\n      id = self.generateId(keyPath, id, instance);\n    }\n\n    // for specs, we should be able to skip this magic\n    if (!storeName || storeName === 'none') {\n      if (typeof options.success === 'function') {\n        options.success();\n      }\n      return;\n    }\n\n    // skip invalid crup operation or models that don't have a valid storeName\n    if (storeName in stores) {\n\n      var _success = options.success;\n      options.success = function () {\n\n        if (typeof _success === 'function') {\n          _success.apply(this, arguments);\n        }\n\n        // trigger events for syncing\n        if (/(create|update|delete)/.test(method)) {\n          self.database.trigger(method, storeName, id);\n        }\n\n        // Update full-text index when needed\n        if ('fullTextIndexFields' in storeInfo) {\n          self.trigger('index', method, storeName, instance);\n        }\n\n        if (/(create|update)/.test(method)) {\n          self.trigger('write', storeName, id);\n        }\n        else if (/delete/.test(method)) {\n          self.trigger('destroy', storeName, id);\n        }\n      };\n\n      var request;\n\n      // query collections\n      if (method === 'read' && !instance.id && instance.model) {\n        request = self.queryCollection(instance);\n      }\n      // regular models\n      else {\n        request = self.operateOnModel(instance, method);\n      }\n\n      options.success && request.done(options.success);\n      options.error && request.fail(options.error);\n    }\n  }\n});\n\nmodule.exports = BackboneDBSync;\n",
    "'use strict';\n\nvar core = require('wunderbits.core');\nvar WBEventEmitter = core.WBEventEmitter;\nvar WBDeferred = core.WBDeferred;\nvar when = core.lib.when;\nvar assert = core.lib.assert;\n\nvar Errors = {\n  'init': 'ERR_ABSTRACT_BACKEND_INITIALIZED'\n};\n\nvar AbstractBackend = WBEventEmitter.extend({\n\n  'defaultKeyPath': 'id',\n\n  'initialize': function () {\n\n    var self = this;\n\n    assert(self.constructor !== AbstractBackend, Errors.init);\n\n    self.ready = new WBDeferred();\n  },\n\n  'connect': function (options) {\n\n    var self = this;\n    self.options = self.options || {};\n    self.options.db = options;\n    self.stores = options.stores;\n    self.openDB(options.name, options.version, options);\n    return self.ready.promise();\n  },\n\n  'openSuccess': function () {\n\n    var self = this;\n    self.trigger('connected');\n    self.ready.resolve();\n  },\n\n  'openFailure': function (code, error) {\n\n    var self = this;\n    self.trigger('error', code, error);\n    self.ready.reject(code, error);\n  },\n\n  // helper to loop through stores\n  'mapStores': function (iterator) {\n\n    var self = this;\n    var results = [];\n    var stores = self.stores;\n    var storeNames = Object.keys(stores);\n    var result, storeName, storeInfo;\n\n    while (storeNames.length) {\n      storeName = storeNames.shift();\n      storeInfo = stores[storeName];\n      result = iterator.call(self, storeName, storeInfo);\n      results.push(result);\n    }\n\n    return results;\n  },\n\n  'truncate': function (callback) {\n\n    var self = this;\n\n    // pause all DB operations\n    var deferred = new WBDeferred();\n    self.ready = new WBDeferred();\n\n    var storeClearPromises = self.mapStores(self.clearStore);\n    when(storeClearPromises).then(function () {\n\n      // reject all DB operations\n      self.ready.reject();\n      deferred.resolve();\n\n      // LEGACY: remove this\n      if (typeof callback === 'function') {\n        callback();\n      }\n\n      self.trigger('truncated');\n    });\n\n    return deferred.promise();\n  },\n\n});\n\nmodule.exports = AbstractBackend;\n",
    "(function (global){\n'use strict';\n\nvar core = require('wunderbits.core');\nvar WBDeferred = core.WBDeferred;\nvar toArray = core.lib.toArray;\nvar when = core.lib.when;\n\nvar AbstractBackend = require('./AbstractBackend');\n\nvar DOMError = global.DOMError || global.DOMException;\nvar indexedDB = global.indexedDB ||\n                global.webkitIndexedDB ||\n                global.mozIndexedDB ||\n                global.msIndexedDB;\n\nvar Constants = {\n  'READ': 'readonly',\n  'WRITE': 'readwrite'\n};\n\nvar Errors = {\n  'privateMode': 'ERR_IDB_FIREFOX_PRIVATE_MODE',\n  'downgrade': 'ERR_IDB_CANT_DOWNGRADE_VERSION',\n  'unknown': 'ERR_IDB_UNKNOWN',\n  'upgradeBrowser': 'ERR_IDB_UPGRADE_BROWSER',\n  'storeCreationFailed': 'ERR_IDB_STORE_CREATION_FAILED',\n  'storeClearFailed': 'ERR_IDB_STORE_CLEAR_FAILED',\n  'notFound': 'ERR_IDB_OBJECT_NOT_FOUND',\n  'getFailed': 'ERR_IDB_STORE_GET_FAILED',\n  'cursorFailed': 'ERR_IDB_CANT_OPEN_CURSOR',\n  'queryFailed': 'ERR_IDB_QUERY_FAILED',\n  'updateFailed': 'ERR_IDB_STORE_UPDATE_FAILED',\n  'destroyFailed': 'ERR_IDB_STORE_DESTROY_FAILED'\n};\n\nvar _super = AbstractBackend.prototype;\nvar IndexedDBBackend = AbstractBackend.extend({\n\n  'initialize': function () {\n\n    var self = this;\n    _super.initialize.apply(self, arguments);\n\n    self.transactionQueue = {};\n    self.isFlushingTransactionQueue = {};\n  },\n\n  'flushNextTransactions': function (storeName, transaction) {\n\n    var self = this;\n    var queue = self.transactionQueue[storeName];\n    var allDone = [];\n    var limit = 100;\n\n    if (queue.length) {\n      self.isFlushingTransactionQueue[storeName] = true;\n\n      var nextInLine = queue.splice(0, limit);\n\n      nextInLine.forEach(function (operation) {\n\n        var promise = operation(transaction);\n        allDone.push(promise);\n      });\n\n      when(allDone).always(function nextDone (transaction) {\n\n        var args = toArray(arguments);\n        var lastArg = args[args.length - 1];\n        transaction = lastArg && lastArg[1];\n\n        if (queue.length) {\n          self.flushNextTransactions(storeName, transaction);\n        }\n        else {\n          self.isFlushingTransactionQueue[storeName] = false;\n        }\n      });\n    }\n  },\n\n  'flushTransactionQueue': function (storeName) {\n\n    var self = this;\n\n    var queue = self.transactionQueue[storeName];\n    var length = queue.length;\n    var flushing = self.isFlushingTransactionQueue[storeName];\n\n    if (length && !flushing) {\n      self.flushNextTransactions(storeName);\n    }\n    else if (!length) {\n      self.isFlushingTransactionQueue[storeName] = false;\n    }\n  },\n\n  'queueTransactionOperation': function (storeName, transactionFunction) {\n\n    var self = this;\n\n    var queue = self.transactionQueue[storeName];\n    if (!queue) {\n      queue = self.transactionQueue[storeName] = [];\n    }\n    queue.push(transactionFunction);\n\n    !self.isFlushingTransactionQueue[storeName] && self.flushTransactionQueue(storeName);\n  },\n\n  'openDB': function (name, version) {\n\n    var self = this;\n\n    if (indexedDB) {\n      var openRequest = indexedDB.open(name, version);\n      openRequest.onerror = self.onRequestError.bind(self);\n      openRequest.onsuccess = self.onRequestSuccess.bind(self);\n      openRequest.onupgradeneeded = self.onUpgradeNeeded.bind(self);\n    }\n    else {\n      self.openFailure('ERR_IDB_CONNECT_FAILED');\n    }\n  },\n\n  'onRequestError': function (event) {\n\n    var self = this;\n    var error = event.target.error;\n    var errorName = error.name;\n    var isDOMError = (error instanceof DOMError);\n\n    if (errorName === 'InvalidStateError' && isDOMError) {\n      self.openFailure(Errors.privateMode);\n    }\n    else if (errorName === 'VersionError' && isDOMError) {\n      self.openFailure(Errors.downgrade);\n    }\n    else {\n      self.openFailure(Errors.unknown, error);\n    }\n  },\n\n  'onRequestSuccess': function (event) {\n\n    var self = this;\n\n    if (self.db) {\n      self.openSuccess();\n      return;\n    }\n\n    var db = event.target.result;\n    if (typeof db.version === 'string') {\n      self.openFailure(Errors.upgradeBrowser);\n      return;\n    }\n\n    self.db = db;\n    self.storeNames = db.objectStoreNames;\n    self.openSuccess();\n  },\n\n  'onUpgradeNeeded': function (event) {\n\n    var self = this;\n\n    var db = event.target.result;\n    self.db = db;\n    self.storeNames = db.objectStoreNames;\n\n    if (!self.options.versionless) {\n      self.trigger('upgrading');\n      self.mapStores(self.createStore);\n    }\n  },\n\n  'createStore': function (storeName, storeInfo) {\n\n    var self = this;\n    var db = self.db;\n\n    // create store, only if doesn't already exist\n    if (!self.storeNames.contains(storeName)) {\n      var request = db.createObjectStore(storeName, {\n        'keyPath': storeInfo.keyPath || self.defaultKeyPath\n      });\n\n      request.onerror = function (error) {\n        self.trigger('error', Errors.storeCreationFailed, error, storeName);\n      };\n    }\n  },\n\n  'clearStore': function (storeName) {\n\n    var self = this;\n    var deferred = new WBDeferred();\n\n    var transaction = self.db.transaction([storeName], Constants.WRITE);\n    var store = transaction.objectStore(storeName);\n\n    var request = store.clear();\n\n    request.onsuccess = function () {\n      deferred.resolve();\n    };\n\n    request.onerror = function (error) {\n      self.trigger('error', Errors.storeClearFailed, error, storeName);\n      deferred.reject();\n    };\n\n    return deferred.promise();\n  },\n\n  'read': function (storeName, json) {\n\n    var self = this;\n    var deferred = new WBDeferred();\n\n    var transaction = self.db.transaction([storeName], Constants.READ);\n    var store = transaction.objectStore(storeName);\n    var id = json[store.keyPath || self.defaultKeyPath] || json.id;\n\n    var request = store.get(id);\n\n    request.onsuccess = function (event) {\n      var json = event.target.result;\n      if (json) {\n        deferred.resolve(json);\n      }\n      else {\n        self.trigger('error', Errors.notFound, null, storeName, json);\n        deferred.reject();\n      }\n    };\n\n    request.onerror = function (error) {\n      self.trigger('error', Errors.getFailed, error, storeName, json);\n      deferred.reject();\n    };\n\n    return deferred.promise();\n  },\n\n  'query': function (storeName) {\n\n    var self = this;\n    var deferred = new WBDeferred();\n\n    var transaction = self.db.transaction([storeName], Constants.READ);\n    var store = transaction.objectStore(storeName);\n    var elements = [];\n\n    var readCursor = store.openCursor();\n\n    if (!readCursor) {\n      self.trigger('error', Errors.cursorFailed, null, storeName);\n      deferred.reject();\n    }\n    else {\n      readCursor.onerror = function (error) {\n        self.trigger('error', Errors.queryFailed, error, storeName);\n        deferred.reject();\n      };\n\n      readCursor.onsuccess = function (e) {\n\n        var cursor = e.target.result;\n        // We're done. No more elements.\n        if (!cursor) {\n          deferred.resolve(elements);\n        }\n        // We have more records to process\n        else {\n          elements.push(cursor.value);\n          cursor['continue']();\n        }\n      };\n    }\n\n    return deferred.promise();\n  },\n\n  'getWriteTransaction': function (storeName) {\n\n    var self = this;\n    return self.db.transaction([storeName], Constants.WRITE);\n  },\n\n  'update': function (storeName, json) {\n\n    var self = this;\n    var deferred = new WBDeferred();\n    var promise = deferred.promise();\n\n    self.queueTransactionOperation(storeName, function updateTransaction (storeTransaction) {\n\n      var transaction = storeTransaction ? storeTransaction : self.getWriteTransaction(storeName);\n      var store = transaction.objectStore(storeName);\n\n      var request = store.put(json);\n\n      request.onsuccess = function () {\n        // pass transaction as second argument as to not resolve db request with wrong data\n        deferred.resolve(undefined, transaction);\n      };\n\n      request.onerror = function (error) {\n        self.trigger('error', Errors.updateFailed, error, storeName, json);\n        deferred.reject();\n      };\n\n      return promise;\n    });\n\n    return promise;\n  },\n\n  'destroy': function (storeName, json) {\n\n    var self = this;\n    var deferred = new WBDeferred();\n    var promise = deferred.promise();\n\n    self.queueTransactionOperation(storeName, function destroyTransaction (storeTransaction) {\n\n      var transaction = storeTransaction ? storeTransaction : self.getWriteTransaction(storeName);\n      var store = transaction.objectStore(storeName);\n      var id = json[store.keyPath || self.defaultKeyPath] || json.id;\n\n      var request = store['delete'](id);\n\n      request.onsuccess = function () {\n        deferred.resolve(undefined, transaction);\n      };\n\n      request.onerror = function (error) {\n        self.trigger('error', Errors.destroyFailed, error, storeName, json);\n        deferred.reject();\n      };\n\n      return promise;\n    });\n\n    return promise;\n  },\n\n  'nuke': function () {\n\n    var self = this;\n    var dbName = self.options.db.name;\n\n    var deferred = new WBDeferred();\n\n    var request = indexedDB.deleteDatabase(dbName);\n\n    request.onsuccess = function () {\n      deferred.resolve();\n    };\n\n    request.onerror = function () {\n      deferred.reject();\n    };\n\n    return deferred.promise();\n  }\n});\n\nmodule.exports = IndexedDBBackend;\n\n}).call(this,typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {})",
    "(function (global){\n'use strict';\n\nvar core = require('wunderbits.core');\nvar WBDeferred = core.WBDeferred;\nvar forEach = core.lib.forEach;\nvar toArray = core.lib.toArray;\n\nvar AbstractBackend = require('./AbstractBackend');\nvar SafeParse = require('../lib/SafeParse');\n\nvar indexedDB = global.indexedDB ||\n                global.webkitIndexedDB ||\n                global.mozIndexedDB ||\n                global.msIndexedDB;\n\nvar MemoryBackend = AbstractBackend.extend({\n\n  'cache': {},\n\n  'localStorageAvailable': true,\n\n  'initialize': function () {\n\n    var self = this;\n    self.ready = new WBDeferred();\n  },\n\n  'connect': function (options) {\n\n    var self = this;\n    self.stores = options.stores;\n\n    self.localStorageAvailable = options.localStorageAvailable;\n\n    // On every version change,\n    // clear out the localStorage &\n    // try again for a better backend\n    if (self.localStorageAvailable) {\n      var store = global.localStorage;\n      if (store.getItem('availableBackend') === 'memory' &&\n          store.getItem('dbVersion') !== '' + options.version) {\n\n        // clear localStorage\n        store.clear();\n\n        // If IDB is available, clear that too\n        if (indexedDB) {\n          var transaction = indexedDB.deleteDatabase(options.name);\n          // Wait till the database is deleted before reloading the app\n          transaction.onsuccess = transaction.onerror = function() {\n            global.location.reload();\n          };\n        }\n        // Otherwise, reload right away\n        else {\n          global.location.reload();\n        }\n      }\n    }\n\n    !self.cache && self.reset();\n\n    self.ready.resolve();\n    return self.ready.promise();\n  },\n\n  'reset': function () {\n\n    var self = this;\n    self.cache = {};\n    forEach(self.stores, function (metaData, storeName) {\n      self.cache[storeName] = {};\n    });\n  },\n\n  'truncate': function (callback) {\n\n    var self = this;\n    var deferred = new WBDeferred();\n    self.ready = new WBDeferred();\n\n    self.reset();\n    self.localStorageAvailable && global.localStorage.clear();\n\n    setTimeout(function () {\n\n      // reject all DB operations\n      self.ready.reject();\n      deferred.resolve();\n\n      // LEGACY: remove this\n      if (typeof callback === 'function') {\n        callback();\n      }\n\n      self.trigger('truncated');\n    }, 50);\n\n    return deferred.promise();\n  },\n\n  'read': function (storeName, json) {\n\n    var self = this;\n    var deferred = new WBDeferred();\n\n    var val;\n    var meta = self.stores[storeName];\n\n    if (self.localStorageAvailable && meta.critical) {\n      var id = json[meta.keyPath] || json.id;\n      val = global.localStorage[storeName + '_' + id];\n      val && (val = SafeParse.json(val));\n    }\n    else {\n      val = self.cache[storeName][json.id];\n    }\n\n    setTimeout(function () {\n\n      if (val !== undefined) {\n        deferred.resolve(val);\n      }\n      else {\n        deferred.reject();\n      }\n    }, 50);\n\n    return deferred.promise();\n  },\n\n  'query': function (storeName) {\n\n    var self = this;\n    var deferred = new WBDeferred();\n    var results = toArray(self.cache[storeName]);\n    return deferred.resolve(results).promise();\n  },\n\n  'update': function (storeName, json) {\n\n    var self = this;\n    var deferred = new WBDeferred();\n\n    var meta = self.stores[storeName];\n\n    if (self.localStorageAvailable && meta.critical) {\n      var id = json[meta.keyPath] || json.id;\n      global.localStorage[storeName + '_' + id] = JSON.stringify(json);\n    }\n    else {\n      self.cache[storeName][json.id] = json;\n    }\n\n    return deferred.resolve().promise();\n  },\n\n  'destroy': function (storeName, json) {\n\n    var self = this;\n    var deferred = new WBDeferred();\n    delete self.cache[storeName][json.id];\n    return deferred.resolve().promise();\n  }\n});\n\nmodule.exports = MemoryBackend;\n\n}).call(this,typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {})",
    "(function (global){\n'use strict';\n\nvar core = require('wunderbits.core');\nvar WBDeferred = core.WBDeferred;\nvar when = core.lib.when;\n\nvar AbstractBackend = require('./AbstractBackend');\nvar printf = require('../lib/printf');\nvar FieldTypes = require('../lib/FieldTypes');\nvar SafeParse = require('../lib/SafeParse');\n\nvar openConnection = global.openDatabase;\nvar escape = global.escape;\nvar unescape = global.unescape;\n\nvar SQL = {\n  'createTable': 'CREATE TABLE IF NOT EXISTS ? (? TEXT PRIMARY KEY, ?)',\n  'truncateTable': 'DELETE FROM ?',\n  'dropTable': 'DROP TABLE IF EXISTS ?',\n  'getAllTables': 'SELECT * FROM sqlite_master WHERE type=\\'table\\'',\n\n  'read': 'SELECT * from ? WHERE ?=\\'?\\' LIMIT 1',\n  'query': 'SELECT * from ?',\n  'upsert': 'INSERT OR REPLACE INTO ? (?) VALUES (?)',\n  'destroy': 'DELETE FROM ? WHERE ?=\\'?\\''\n};\n\n// We need to map schema types to websql types\nvar TYPES = { 'default': 'TEXT' };\nTYPES[FieldTypes.Float] = 'REAL';\nTYPES[FieldTypes.Integer] = 'INTEGER';\n\nvar WebSQLBackend = AbstractBackend.extend({\n\n  'properties': {\n    'dbSize': (5 * 1024 * 1024)\n  },\n\n  'openDB': function (name, version, options) {\n\n    var self = this;\n    var readyDeferred = self.ready;\n\n    // in case safari is broken after an update\n    var initTimeout = setTimeout(function () {\n      self.openFailure('ERR_WS_CONNECT_TIMEOUT');\n    }, 2000);\n\n    readyDeferred.done(function () {\n      clearTimeout(initTimeout);\n    });\n\n    try {\n      // Safari needs the DB to initialized with **exactly** 5 mb storage\n      var dbSize = options.dbSize || self.dbSize;\n      var db = openConnection(name, '', name, dbSize);\n      self.db = db;\n\n      // WebSQL versions are strings\n      version = '' + version;\n\n      // check if we need to upgrade the schema\n      if (db.version !== version && !options.versionless) {\n        db.changeVersion(db.version || '', version, function () {\n\n          self.onUpgradeNeeded()\n            .done(self.openSuccess, self)\n            .fail(self.openFailure, self);\n        });\n      }\n      // schema correct\n      else {\n        self.openSuccess();\n      }\n    } catch (error) {\n      self.openFailure('ERR_WS_CONNECT_FAILED', error);\n    }\n  },\n\n  'execute': function (sql) {\n\n    var self = this;\n\n    var deferred = new WBDeferred();\n\n    // create a transaction\n    self.db.transaction(function (transaction) {\n\n      // execute the sql\n      transaction.executeSql(sql, [], function (tx, result) {\n        deferred.resolve(result);\n      }, function (tx, err) {\n        deferred.reject(err);\n      });\n    });\n\n    return deferred.promise();\n  },\n\n  'parseGeneric': function (data) {\n    return SafeParse.json(unescape(data.json));\n  },\n\n  'populateGeneric': function (keys, values, json) {\n\n    keys.push('json');\n    values.push('\\'' + escape(JSON.stringify(json)) + '\\'');\n  },\n\n  'parseFields': function (data, fields) {\n    var obj = {\n      'id': data.id\n    };\n\n    var name, type, value, parsed;\n    for (name in fields) {\n      type = fields[name];\n      value = data[name];\n\n      if (data[name] !== undefined) {\n        if (type === FieldTypes.Integer) {\n          parsed = parseInt(value, 10);\n          if (isNaN(value)) {\n            console.warn('failed to parse %s as Integer', value);\n          }\n          value = parsed || 0;\n        }\n        else if (type === FieldTypes.Float) {\n          parsed = parseFloat(value, 10);\n          if (isNaN(value)) {\n            console.warn('failed to parse %s as Float', value);\n          }\n          value = parsed || 0;\n        }\n        else {\n\n          // don't unescape nulls & undefineds\n          value = value && unescape(value);\n\n          if (type === FieldTypes.Boolean) {\n            value = (value === 'true');\n          }\n          else if (type === FieldTypes.Array) {\n            value = SafeParse.json(value) || [];\n          }\n          else if (type === FieldTypes.Object) {\n            value = SafeParse.json(value) || {};\n          }\n          else if (value === '') {\n            value = null;\n          }\n        }\n        obj[name] = value;\n      }\n    }\n\n    return obj;\n  },\n\n  'populateFields': function (keys, values, json, fields, keyPath) {\n\n    var name, type, value;\n    for (name in fields) {\n\n      type = fields[name];\n      value = json[name];\n\n      if (value !== undefined && name !== keyPath) {\n\n        if (type === FieldTypes.Float || type === FieldTypes.Integer) {\n          value = (!!value && !isNaN(value)) ? value : 0;\n        }\n        else if (type === FieldTypes.Array && Array.isArray(value)) {\n          value = '\\'' + escape(JSON.stringify(value)) + '\\'';\n        }\n        else if (type === FieldTypes.Object) {\n          value = '\\'' + escape(JSON.stringify(value)) + '\\'';\n        }\n        else {\n          value = (value !== null) ? '\\'' + escape(value) + '\\'' : 'NULL';\n        }\n\n        keys.push('\"' + name + '\"');\n        values.push(value);\n      }\n    }\n  },\n\n  'toArray': function (rows, fields) {\n\n    var self = this;\n    var count = rows.length;\n    var returnRows = new Array(count);\n    var parse = self[fields ? 'parseFields' : 'parseGeneric'];\n\n    var data;\n    for (var index = 0; index < count; index++) {\n      data = rows.item(index);\n      returnRows[index] = parse.call(self, data, fields);\n    }\n\n    return returnRows;\n  },\n\n  'onUpgradeNeeded': function () {\n\n    var self = this;\n\n    var deferred = new WBDeferred();\n\n    self.trigger('upgrading');\n\n    var storeClearPromises = self.mapStores(self.clearStore);\n    when(storeClearPromises).always(function () {\n\n      self.listTables()\n        .done(function (tables) {\n\n          tables = tables || [];\n\n          var dropPromises = tables.length ? tables.map(function (table) {\n            return self.dropStore(table);\n          }) : [];\n\n          when(dropPromises).always(function () {\n\n            var storeCreationDeferreds = self.mapStores(self.createStore);\n            when(storeCreationDeferreds)\n              .done(function () {\n                deferred.resolve();\n              })\n              .fail(function () {\n                deferred.reject();\n              });\n          })\n          .fail(function () {\n            console.warn('table drop failed');\n          });\n        })\n        .fail(function () {\n          console.warn('get tables failed');\n        });\n    })\n    .fail(function () {\n      console.warn('clear failed');\n    });\n\n    return deferred.promise();\n  },\n\n  'createStore': function (storeName, storeInfo) {\n\n    var self = this;\n\n    var deferred = new WBDeferred();\n    var keyPath = storeInfo.keyPath || self.defaultKeyPath;\n    var fields = storeInfo.fields;\n\n    var sql = SQL.createTable;\n    if (!fields) {\n      sql = printf(sql, storeName, keyPath, 'json TEXT');\n    }\n    else {\n\n      if (keyPath === 'id') {\n        delete fields.id;\n      }\n\n      // convert our Field types to WebSQL types\n      var columns = Object.keys(fields).map(function (type) {\n        return '\"' + type + '\" ' + (TYPES[fields[type]] || TYPES.default);\n      });\n\n      sql = printf(sql, storeName, keyPath, columns.join(', '));\n    }\n\n    self.execute(sql)\n      .done(deferred.resolve, deferred)\n      .fail(function (error) {\n        self.trigger('error', 'ERR_WS_STORE_CREATION_FAILED', error, storeName);\n        deferred.reject();\n      });\n\n    return deferred.promise();\n  },\n\n  'dropStore': function (storeName) {\n\n    var self = this;\n    var deferred = new WBDeferred();\n    var sql = printf(SQL.dropTable, storeName);\n    self.execute(sql)\n      .done(deferred.resolve, deferred)\n      .fail(function () {\n        deferred.reject();\n      });\n\n    return deferred.promise();\n  },\n\n  'clearStore': function (storeName) {\n\n    var self = this;\n    var deferred = new WBDeferred();\n\n    var sql = printf(SQL.truncateTable, storeName);\n    self.execute(sql)\n      .done(deferred.resolve, deferred)\n      .fail(function (error) {\n        self.trigger('error', 'ERR_WS_CLEAR_FAILED', error, storeName);\n        deferred.reject();\n      });\n\n    return deferred.promise();\n  },\n\n  'listTables': function () {\n\n    var self = this;\n    var deferred = new WBDeferred();\n\n    self.execute(SQL.getAllTables)\n      .done(function (result) {\n\n        var rows = result.rows;\n        var data;\n        var count = rows.length;\n        var returnRows = [];\n        for (var index = 1; index < count; index++) {\n          data = rows.item(index);\n          returnRows.push(data.name);\n        }\n\n        deferred.resolve(returnRows);\n      });\n\n    return deferred.promise();\n  },\n\n  'read': function (storeName, json) {\n\n    var self = this;\n\n    var deferred = new WBDeferred();\n\n    var storeInfo = self.stores[storeName];\n    var fields = storeInfo.fields;\n\n    var keyPath = storeInfo.keyPath || self.defaultKeyPath;\n    var id = json[keyPath] || json.id;\n\n    var sql = printf(SQL.read, storeName, keyPath, id);\n    self.execute(sql)\n      .done(function (result) {\n        if (result.rows.length === 0) {\n          self.trigger('error', 'ERR_WS_OBJECT_NOT_FOUND', null, storeName, json);\n          deferred.reject();\n        }\n        else {\n          var elements = self.toArray(result.rows, fields);\n          deferred.resolve(elements[0]);\n        }\n      })\n      .fail(function (error) {\n        self.trigger('error', 'ERR_WS_READ_FAILED', error, storeName, json);\n        deferred.reject();\n      });\n\n    return deferred.promise();\n  },\n\n  'query': function (storeName) {\n\n    var self = this;\n    var deferred = new WBDeferred();\n\n    var storeInfo = self.stores[storeName];\n    var fields = storeInfo && storeInfo.fields;\n\n    var sql = printf(SQL.query, storeName);\n    self.execute(sql)\n      .done(function (result) {\n        var elements = self.toArray(result.rows, fields);\n        deferred.resolve(elements);\n      })\n      .fail(function (error) {\n        self.trigger('error', 'ERR_WS_QUERY_FAILED', error, storeName);\n        deferred.reject();\n      });\n\n    return deferred.promise();\n  },\n\n  'update': function (storeName, json) {\n\n    var self = this;\n    var deferred = new WBDeferred();\n\n    var storeInfo = self.stores[storeName];\n    var fields = storeInfo.fields;\n\n    var keyPath = storeInfo.keyPath || self.defaultKeyPath;\n    var id = json[keyPath] || json.id;\n\n    var keys = ['\"' + keyPath + '\"'];\n    var values = ['\\'' + id + '\\''];\n\n    var populate = self[fields ? 'populateFields': 'populateGeneric'];\n    populate.call(self, keys, values, json, fields, keyPath);\n\n    var sql = printf(SQL.upsert, storeName, keys, values);\n    try {\n\n      self.execute(sql)\n        .done(function () {\n          deferred.resolve();\n        })\n        .fail(function (error) {\n          self.trigger('error', 'ERR_WS_UPDATE_FAILED',\n              error, storeName, json);\n          deferred.reject();\n        });\n    }\n    catch (error) {\n      self.trigger('error', 'ERR_WS_UPDATE_FAILED',\n          error, storeName, json);\n      deferred.reject();\n    }\n\n    return deferred.promise();\n  },\n\n  'destroy': function (storeName, json) {\n\n    var self = this;\n    var deferred = new WBDeferred();\n\n    var storeInfo = self.stores[storeName];\n    var keyPath = storeInfo.keyPath || self.defaultKeyPath;\n    var id = json[keyPath] || json.id;\n\n    var sql = printf(SQL.destroy, storeName, keyPath, id);\n    self.execute(sql)\n      .done(function () {\n        deferred.resolve();\n      })\n      .fail(function (error) {\n        self.trigger('error', 'ERR_WS_DESTROY_FAILED',\n            error, storeName, json);\n        deferred.reject();\n      });\n\n    return deferred.promise();\n  },\n\n  'nuke': function () {\n\n    var self = this;\n    console.warn('cant delete websql database');\n    return self.truncate();\n  }\n\n});\n\nmodule.exports = WebSQLBackend;\n\n}).call(this,typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {})",
    "(function (global){\n'use strict';\n\nvar core = require('wunderbits.core');\nvar WBEventEmitter = core.WBEventEmitter;\nvar WBDeferred = core.WBDeferred;\nvar assert = core.lib.assert;\nvar extend = core.lib.extend;\nvar clone = core.lib.clone;\nvar merge = core.lib.merge;\nvar toArray = core.lib.toArray;\n\nvar MemoryBackend = require('./Backends/MemoryBackend');\nvar WebSQLBackend = require('./Backends/WebSQLBackend');\nvar IndexedDBBackend = require('./Backends/IndexedDBBackend');\n\nvar chrome = global.chrome;\nvar isChromeApp = !!(chrome && chrome.app && chrome.app.runtime);\nvar localStorageAvailable = true;\n\n// tests for storage engine availability\nvar backendTests = {\n  'indexeddb': [\n    'indexedDB',\n    'webkitIndexedDB',\n    'mozIndexedDB',\n    'msIndexedDB'\n  ],\n  'websql': [\n    'openDatabase'\n  ]\n};\n\nvar backends = {\n  'memory': MemoryBackend,\n  'websql': WebSQLBackend,\n  'indexeddb': IndexedDBBackend\n};\n\nvar WBDatabase = WBEventEmitter.extend({\n\n  'initialize': function (options) {\n\n    var self = this;\n\n    options = options || {};\n    self.crud = {};\n\n    self.ready = new WBDeferred();\n\n    assert.object(options.schema);\n\n    var schema = options.schema;\n    self.stores = schema.stores;\n\n    var database = schema.database;\n    self.name = database.name;\n\n    self.versionless = !!options.versionless;\n\n    // make version change with schema\n    var version = (Object.keys(self.stores).length * 10e6);\n    version += (parseInt(database.version, 10) || 1);\n    self.version = version;\n  },\n\n  'init': function (backendName, options) {\n\n    var self = this;\n\n    // Initialize only once\n    var ready = self.ready;\n    if (ready.state() === 'resolved') {\n      return ready.promise();\n    }\n\n    backendName = self.findAvailableBackend(backendName);\n    self.backendName = backendName;\n\n    var loggers = self.initLogger(backendName.toUpperCase());\n    var stores = self.stores;\n\n    options = merge(options || {}, {\n      'name': self.name,\n      'version': self.version,\n      'versionless': self.versionless,\n      'stores': stores,\n      'infoLog': loggers.info,\n      'errorLog': loggers.error,\n      'localStorageAvailable': localStorageAvailable\n    });\n\n    // try to init the available backend\n    self.initBackend(backendName, options);\n\n    return ready.promise();\n  },\n\n  'currentBackend': function () {\n    var self = this;\n    return self.backendName;\n  },\n\n  // Define the loggers\n  'initLogger': function (label) {\n    return {\n      'info': console.info.bind(console, '[' + label + ']'),\n      'error': console.error.bind(console, '[' + label + ']')\n    };\n  },\n\n  'initBackend': function (backendName, options) {\n\n    var self = this;\n    var BackendClass = backends[backendName];\n\n    var backend = self.backend = new BackendClass();\n    self.options = options;\n\n    // pipe backend errors\n    backend.on('error', function () {\n      var args = toArray(arguments);\n      args.unshift('error');\n      self.trigger.apply(self, args);\n    });\n\n    backend.connect(options)\n      .done(self.initSuccess, self)\n      .fail(self.initFailure, self);\n  },\n\n  'initSuccess': function () {\n\n    var self = this;\n    var backend = self.backend;\n\n    var crudOps = {\n      'create': backend.update,\n      'read': backend.read,\n      'update': backend.update,\n      'delete': backend.destroy,\n      'query': backend.query\n    };\n\n    // bind crud operations to the backend for context\n    // also block all DB operations till db is ready\n    Object.keys(crudOps).forEach(function (key) {\n      var fn = crudOps[key];\n      crudOps[key] = function () {\n        var args = arguments;\n        var deferred = new WBDeferred();\n        var ready = backend.ready;\n        ready.done(function () {\n          fn.apply(backend, args)\n            .done(deferred.resolve, deferred)\n            .fail(deferred.reject, deferred);\n        });\n        ready.fail(deferred.reject, deferred);\n        return deferred.promise();\n      };\n    });\n\n    // export crud functions\n    extend(self.crud, crudOps);\n\n    // announce once backend is ready\n    self.ready.resolve();\n    self.publish('ready', {\n      'stores': self.stores\n    });\n  },\n\n  'initFailure': function () {\n\n    var self = this;\n    // announce db failure\n    self.ready.reject();\n  },\n\n  // Test for available storage-backends\n  'findAvailableBackend': function (requestedBackend) {\n\n    // way to force a specific backend on init (used by tests)\n    if (requestedBackend in backendTests) {\n      return requestedBackend;\n    }\n    else if (chrome && chrome.storage) {\n      return 'indexeddb';\n    }\n\n    // IF this check has been run previously, load from localStorage\n    // But, don't break the app if local storage is not available\n    // (disabled by the user)!\n    try {\n      // throws exception in chrome when cookies are disabled\n      var availableBackend = global.localStorage.getItem('availableBackend');\n      if (availableBackend in backendTests) {\n        return availableBackend;\n      }\n    }\n    catch (e) {\n      // If localStorage lookup fails, we probably have no storage at all\n      // Use memory\n      localStorageAvailable = false;\n      return 'memory';\n      //document.write('HTML5 local storage ' +\n      //  '(controlled by your cookie settings) ' +\n      //  'is required in order use wunderlist.');\n    }\n\n    // Test for available storage options, but use memory backend for tests\n    var available;\n    for (var name in backendTests) {\n      var tests = clone(backendTests[name]);\n      while (tests.length && !available) {\n        if (!!global[tests.shift()]) {\n          available = name;\n          break;\n        }\n      }\n    }\n\n    // If none-available, use in-memory as default\n    return available || 'memory';\n  },\n\n  // Define getAll for the app to load all data in the beginning\n  'getAll': function (storeName, success, error) {\n\n    var self = this;\n    self.ready.done(function () {\n\n      var request = self.backend.query(storeName);\n      success && request.done(success);\n      error && request.fail(error);\n    });\n  },\n\n  // Empty the database, but don't destroy the structure\n  'truncate': function (callback) {\n\n    var self = this;\n    self.ready.done(function () {\n\n      // clear out localstorage as well (in case anything ever was left there)\n      if (self.backendName !== 'memory' && !isChromeApp) {\n        localStorageAvailable && global.localStorage.clear();\n      }\n\n      self.backend.truncate().then(callback);\n    });\n  }\n});\n\nmodule.exports = WBDatabase;\n\n}).call(this,typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {})",
    "(function (global){\n'use strict';\n\nvar chrome = global.chrome;\nvar isChromeApp = chrome && chrome.storage;\n\nvar localStorageClass;\nif (isChromeApp) {\n  localStorageClass = require('./localStorage/WBChromeLocalStorage');\n} else {\n  localStorageClass = require('./localStorage/WBBrowserLocalStorage');\n}\n\nmodule.exports = localStorageClass;\n\n}).call(this,typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {})",
    "'use strict';\n\nvar core = require('wunderbits.core');\nvar WBSingleton = core.WBSingleton;\nvar extend = core.lib.extend;\n\nvar FieldTypes = require('./lib/FieldTypes');\n\nvar BaseSchema = WBSingleton.extend({\n  'FieldTypes': FieldTypes,\n  'fields': {}\n});\n\nvar SpecialFieldTypes = {};\nObject.keys(FieldTypes).forEach(function (type) {\n  SpecialFieldTypes[type.toLowerCase() + 's'] = FieldTypes[type];\n});\n\nfunction CustomExtend (properties) {\n\n  // extract fields, to be merged later\n  var fields = properties.fields;\n  delete properties.fields;\n\n  // extend the schema\n  var schema = WBSingleton.extend.call(this, properties);\n  schema.extend = CustomExtend;\n\n  // translate the alternative format schema\n  var key, val, type;\n  for (key in fields) {\n    val = fields[key];\n    type = SpecialFieldTypes[key];\n    if (type && Array.isArray(val)) {\n      while(val.length) {\n        fields[val.shift()] = type;\n      }\n      delete fields[key];\n    }\n  }\n\n  // merge fields with the parent\n  schema.fields = extend({}, schema.fields, fields);\n  return schema;\n}\n\nBaseSchema.extend = CustomExtend;\n\nmodule.exports = BaseSchema;\n",
    "'use strict';\n\nmodule.exports = {\n  'BackboneDBSync': require('./BackboneDBSync'),\n  'WBDatabase': require('./WBDatabase'),\n  'WBLocalStorage': require('./WBLocalStorage'),\n  'WBSchema': require('./WBSchema')\n};\n",
    "module.exports = {\n  'Array': 'ARRAY',\n  'Boolean': 'BOOLEAN',\n  'DateTime': 'DATETIME',\n  'Float': 'FLOAT',\n  'Integer': 'INTEGER',\n  'Object': 'OBJECT',\n  'Text': 'TEXT'\n};",
    "'use strict';\n\nvar core = require('wunderbits.core');\nvar WBSingleton = core.WBSingleton;\n\nfunction parse (jsonString) {\n  try {\n    return JSON.parse(jsonString);\n  } catch (e) {\n    console.warn('Unable to parse \"' + jsonString + '\"');\n  }\n  return;\n}\n\nvar SafeParse = WBSingleton.extend({\n  'json': parse\n});\n\nmodule.exports = SafeParse;\n",
    "'use strict';\n\nfunction replacer () {\n  return (Math.random() * 16 | 0).toString(16);\n}\n\n// Auto-generate IDs for new objects\nfunction autoID () {\n  return 'lw' + (new Array(31)).join('x').replace(/x/g, replacer);\n}\n\nmodule.exports = autoID;\n",
    "'use strict';\n\n// Generate SQLs, WebSQL's formatter blows\nfunction printf (text) {\n\n  var i = 1;\n  var args = arguments;\n\n  return text.replace(/\\?/g, function () {\n    var value = args[i++];\n    if (value === undefined) {\n      return '';\n    }\n    if (Array.isArray(value)) {\n      return value.join(', ');\n    }\n    return value;\n  });\n}\n\nmodule.exports = printf;\n",
    "(function (global){\n'use strict';\n\nvar core = require('wunderbits.core');\nvar WBClass = core.WBClass;\nvar WBDeferred = core.WBDeferred;\n\nvar localStorage;\ntry {\n  localStorage = global.localStorage;\n}\ncatch (e) {\n  console.warn(e);\n}\n\nvar WBBrowserLocalStorage = WBClass.extend({\n\n  'getItem': function (key) {\n\n    var deferred = new WBDeferred();\n    var value = localStorage.getItem(key);\n    return deferred.resolve(value).promise();\n  },\n\n  'setItem': function (key, value) {\n\n    var deferred = new WBDeferred();\n    try {\n      localStorage.setItem(key, value);\n      deferred.resolve();\n    }\n    catch (e) {\n      deferred.reject(e);\n    }\n    return deferred.promise();\n  },\n\n  'removeItem': function (key) {\n\n    var deferred = new WBDeferred();\n    localStorage.removeItem(key);\n    return deferred.resolve().promise();\n  },\n\n  'clear': function () {\n\n    var deferred = new WBDeferred();\n    localStorage.clear();\n    return deferred.resolve().promise();\n  }\n});\n\nmodule.exports = WBBrowserLocalStorage;\n\n}).call(this,typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {})",
    "(function (global){\n'use strict';\n\nvar core = require('wunderbits.core');\nvar WBClass = core.WBClass;\nvar WBDeferred = core.WBDeferred;\n\nvar chrome = global.chrome;\nvar localStorage = chrome && chrome.storage && chrome.storage.local;\n\nvar WBChromeLocalStorage = WBClass.extend({\n\n  'getItem': function (key) {\n\n    var deferred = new WBDeferred();\n\n    localStorage.get(key, function (data) {\n\n      if (chrome.runtime.lastError) {\n        deferred.reject(chrome.runtime.lastError);\n      }\n      else {\n        var value = data[key];\n        deferred.resolve(value);\n      }\n    });\n\n    return deferred.promise();\n  },\n\n  'setItem': function (key, value) {\n\n    var deferred = new WBDeferred();\n\n    var data = {};\n    data[key] = value;\n\n    localStorage.set(data, function () {\n\n      if (chrome.runtime.lastError) {\n        deferred.reject(chrome.runtime.lastError);\n      }\n      else {\n        deferred.resolve();\n      }\n    });\n\n    return deferred.promise();\n  },\n\n  'removeItem': function (key) {\n\n    var deferred = new WBDeferred();\n\n    localStorage.remove(key, function () {\n\n      if (chrome.runtime.lastError) {\n        deferred.reject(chrome.runtime.lastError);\n      }\n      else {\n        deferred.resolve();\n      }\n    });\n\n    return deferred.promise();\n  },\n\n  'clear': function () {\n\n    var deferred = new WBDeferred();\n\n    localStorage.clear(function () {\n\n      if (chrome.runtime.lastError) {\n        deferred.reject(chrome.runtime.lastError);\n      }\n      else {\n        deferred.resolve();\n      }\n    });\n\n    return deferred.promise();\n  }\n});\n\nmodule.exports = WBChromeLocalStorage;\n\n}).call(this,typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {})"
  ]
}